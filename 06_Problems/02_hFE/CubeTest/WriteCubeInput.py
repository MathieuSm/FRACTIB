import os
import numpy as np

# Define functions
def WriteRaw(ImageArray, OutputFileName, PixelType):

    if PixelType == 'uint':

        MinValue = ImageArray.min()

        if MinValue < 0:
            ShiftedImageArray = ImageArray + abs(MinValue)
            MaxValue = ShiftedImageArray.max()
        elif MinValue > 0:
            ShiftedImageArray = ImageArray - MinValue
            MaxValue = ShiftedImageArray.max()
        else :
            ShiftedImageArray = ImageArray
            MaxValue = ShiftedImageArray.max()

        ScaledImageArray = ShiftedImageArray / MaxValue * 255

        CastedImageArray = ScaledImageArray.astype(np.uint8)

    elif PixelType == 'short':
        CastedImageArray = ImageArray.astype(np.short)
    elif PixelType == 'float':
        CastedImageArray = ImageArray.astype('float32')

    File = np.memmap(OutputFileName, dtype=CastedImageArray.dtype, mode='w+', shape=CastedImageArray.shape)
    File[:] = CastedImageArray[:]
    del File

    return
def WriteMHD(ImageArray, Spacing, Offset, Path, FileName, PixelType='uint'):

    if PixelType == 'short' or PixelType == 'float':
        if len(ImageArray.shape) == 2:

            Array_3D = np.zeros((1,ImageArray.shape[0],ImageArray.shape[1]))

            for j in range(ImageArray.shape[0]):
                for i in range(ImageArray.shape[1]):
                    Array_3D[0,j,i] = ImageArray[j,i]

            ImageArray = Array_3D

    nz, ny, nx = np.shape(ImageArray)

    lx = float(Spacing[0])
    ly = float(Spacing[1])
    lz = float(Spacing[2])

    TransformMatrix = '1 0 0 0 1 0 0 0 1'
    X_o, Y_o, Z_o = float(Offset[0]), float(Offset[1]), float(Offset[2])
    CenterOfRotation = '0 0 0'
    AnatomicalOrientation = 'LPS'

    outs = open(os.path.join(Path, FileName) + '.mhd', 'w')
    outs.write('ObjectType = Image\n')
    outs.write('NDims = 3\n')
    outs.write('BinaryData = True\n')
    outs.write('BinaryDataByteOrderMSB = False\n')
    outs.write('CompressedData = False\n')
    outs.write('TransformMatrix = %s \n' % TransformMatrix)
    outs.write('Offset = %g %g %g\n' % (X_o, Y_o, Z_o))
    outs.write('CenterOfRotation = %s \n' % CenterOfRotation)
    outs.write('AnatomicalOrientation = %s \n' % AnatomicalOrientation)
    outs.write('ElementSpacing = %g %g %g\n' % (lx, ly, lz))
    outs.write('DimSize = %i %i %i\n' % (nx, ny, nz))

    if PixelType == 'uint':
        outs.write('ElementType = %s\n' % 'MET_UCHAR')
    elif PixelType == 'short':
        outs.write('ElementType = %s\n' % 'MET_SHORT')
    elif PixelType == 'float':
        outs.write('ElementType = %s\n' % 'MET_FLOAT')

    outs.write('ElementDataFile = %s\n' % (FileName + '.raw'))
    outs.close()

    WriteRaw(ImageArray, os.path.join(Path, FileName) + '.raw', PixelType)

    return


# Define directory and parameters
WorkingDirectory = os.getcwd()
FilePath = os.path.join(WorkingDirectory,'06_Problems/02_hFE/CubeTest/')
CubeLength = 1
Compression = 0.1   # Relative compression
NCubes = 5      # Number of discretized cubes by side
UMAT_File = 'Elastic_UMAT'    # Name of UMAT file
E = 1E4         # Young's modulus
Nu = 0.3        # Poisson's ratio

# Define input file name and create it
NCubes_Total = NCubes**3
FileName = str(NCubes_Total) + '_Cubes_UMAT.inp'
File = open(FilePath+FileName,'w')


# Write heading
File.write('*Heading\n')
File.write('** Job name: ' + FileName[:-4] + ' Model name: Cube\n')
File.write('** Generated by: Python\n')
File.write('*Preprint, echo=NO, model=NO, history=NO, contact=NO\n')
File.write('**\n')

# Compute nodes coordinates
NodesCoordinates = np.linspace(-CubeLength/2,CubeLength/2,NCubes+1).round(3)

# Write part
File.write('** PARTS\n')
File.write('**\n')
File.write('*Part, name=CUBE\n')

## Write part nodes
File.write('*Node\n')

i = 1
NodesCoordinates_Matrix = np.zeros((len(NodesCoordinates)**3,4))

## Define space length for node coordinate
L_StrNode = len(str(len(NodesCoordinates)**3))
L_StrCoordinates = len(str(min(NodesCoordinates)))
SpaceNumber = max(L_StrNode,L_StrCoordinates)
for x in NodesCoordinates[::-1]:
    for z in NodesCoordinates[::-1]:
        for y in NodesCoordinates[::-1]:
            File.write('   ')

            ## Write node number
            for Space in range(SpaceNumber - len(str(i))):
                File.write(' ')
            File.write(str(i) + ',   ')

            ## Write node x coordinate
            for Space in range(SpaceNumber - len(str(x))):
                File.write(' ')
            File.write(str(x) + ',   ')

            ## Write node y coordinate
            for Space in range(SpaceNumber - len(str(y))):
                File.write(' ')
            File.write(str(y) + ',   ')

            ## Write node z coordinate
            for Space in range(SpaceNumber - len(str(z))):
                File.write(' ')
            File.write(str(z) + '\n')

            NodesCoordinates_Matrix[i-1,:] = [i,x,y,z]
            i += 1

## Compute elements connectivity
ElementNumber = NCubes_Total
Connectivity_Matrix = np.zeros((ElementNumber,9),dtype='int')
for i in range(NCubes):
    for j in range(NCubes):
        for k in range(NCubes):

            ## Initialize element connectivity array
            Connectivity = np.array([])

            ## Select 1st node
            Filter1 = NodesCoordinates_Matrix[:, 1] == NodesCoordinates[-1-i]
            Filter2 = NodesCoordinates_Matrix[:, 2] == NodesCoordinates[-1-j]
            Filter3 = NodesCoordinates_Matrix[:, 3] == NodesCoordinates[k]
            Node_Info = NodesCoordinates_Matrix[Filter1 & Filter2 & Filter3][0]
            NodeNumber = Node_Info[0].astype('int')

            ## Append first 4 nodes in connectivity
            Connectivity = np.append(Connectivity,
                                     [NodeNumber,
                                      NodeNumber+1,
                                      NodeNumber-NCubes,
                                      NodeNumber-NCubes-1])

            ## Select next node
            Filter1 = NodesCoordinates_Matrix[:, 1] == NodesCoordinates[-2-i]
            Node_Info = NodesCoordinates_Matrix[Filter1 & Filter2 & Filter3][0]
            NodeNumber = Node_Info[0].astype('int')

            ## Append last 4 nodes in connectivity
            Connectivity = np.append(Connectivity,
                                     [NodeNumber,
                                      NodeNumber+1,
                                      NodeNumber-NCubes,
                                      NodeNumber-NCubes-1])

            ## Append element number
            Connectivity = np.append(Connectivity,[ElementNumber])
            ElementNumber -= 1
            Connectivity_Matrix[ElementNumber,:] = Connectivity[::-1]

## Write element connectivity
File.write('*Element, type=C3D8\n')
SpaceNumber = L_StrNode
for Element in range(NCubes_Total):

    ## Write element number
    ElementConnectivity = Connectivity_Matrix[Element,:]
    File.write(str(ElementConnectivity[0]) + ', ')

    ## Write element connectivity
    for Node in range(1,9):
        NodeNumber = str(ElementConnectivity[Node])

        ## Add space for alignment, if necessary
        for Space in range(SpaceNumber-len(NodeNumber)):
            File.write(' ')

        if Node < 8:
            File.write(NodeNumber + ', ')
        else:
            File.write(NodeNumber + '\n')

## Write node set
File.write('*Nset, nset=NODESET, generate\n')
File.write(' 1,  ' + str(len(NodesCoordinates)**3) + ',  1\n')
File.write('*Elset, elset=NODESET\n')
for i in range(NCubes_Total-1):
    File.write(str(i+1) + ',')
    if np.mod((i+1)/16,1) == 0.0:
        File.write('\n')
    else:
        File.write(' ')
File.write(str(NCubes_Total) + ',\n')

## Write section parameters
File.write('** Section: Section-1-NODESET\n')
File.write('*Solid Section, elset=NODESET, material=' + UMAT_File + '\n')
File.write(',\n')
File.write('*End Part\n')
File.write('**\n')
File.write('**\n')

# Write assembly
File.write('** ASSEMBLY\n')
File.write('**\n')
File.write('*Assembly, name=Assembly\n')
File.write('**\n')

## Write instance
File.write('*Instance, name=CUBEINSTANCE, part=CUBE\n')
File.write('*End Instance\n')
File.write('**\n')

## Write bottom nodes set
File.write('*Nset, nset=BOTTOMNODES, instance=CUBEINSTANCE\n')
Filter = NodesCoordinates_Matrix[:, 3] == NodesCoordinates[0]
BottomNodes = NodesCoordinates_Matrix[Filter][:,0].astype('int')
File.write(' ' + str(BottomNodes[0]))
SpaceNumber = L_StrNode
i = 1
for Node in BottomNodes[1:]:

    File.write(', ')

    if np.mod(i/16,1) == 0.0:
        File.write('\n')

    ## Add space for alignment, if necessary
    NodeNumber = str(Node)
    for Space in range(SpaceNumber-len(NodeNumber)):
        File.write(' ')

    File.write(NodeNumber)

    if Node == BottomNodes[-1]:
        File.write('\n')

    i += 1

## Write bottom elements set
File.write('*Elset, elset=BOTTOMNODES, instance=CUBEINSTANCE\n')
BottomElementNumber = 0
for Element in range(NCubes_Total):
    ElementNodes = Connectivity_Matrix[:,1:][Element,:]
    if np.isin(ElementNodes,BottomNodes).any():
        if BottomElementNumber > 0:
            File.write(' ')
        ElementNumber = str(Connectivity_Matrix[Element,0])
        for Space in range(SpaceNumber - len(ElementNumber)):
            File.write(' ')
        File.write(ElementNumber + ',')
        BottomElementNumber += 1
    if Element == NCubes_Total-1:
        File.write('\n')

## Write top nodes set
File.write('*Nset, nset=TOPNODES, instance=CUBEINSTANCE\n')
Filter = NodesCoordinates_Matrix[:, 3] == NodesCoordinates[-1]
NewFilter = NodesCoordinates_Matrix[:, 2] == NodesCoordinates[0]
TopNodes = NodesCoordinates_Matrix[Filter & NewFilter][:, 0].astype('int')
File.write(' ' + str(TopNodes[0]))
SpaceNumber = L_StrNode
i = 1
for Node in TopNodes[1:]:

    File.write(', ')

    if np.mod(i/16,1) == 0.0:
        File.write('\n')

    ## Add space for alignment, if necessary
    NodeNumber = str(Node)
    for Space in range(SpaceNumber - len(NodeNumber)):
        File.write(' ')

    File.write(NodeNumber)

    if Node == TopNodes[-1]:
        File.write('\n')

    i += 1

## Write top elements set
File.write('*Elset, elset=TOPNODES, instance=CUBEINSTANCE\n')
TopElementNumber = 0
for Element in range(NCubes_Total):
    ElementNodes = Connectivity_Matrix[:,1:][Element,:]
    if np.isin(ElementNodes,TopNodes).any():
        if TopElementNumber > 0:
            File.write(' ')
        ElementNumber = str(Connectivity_Matrix[Element,0])
        for Space in range(SpaceNumber - len(ElementNumber)):
            File.write(' ')
        File.write(ElementNumber + ',')
        TopElementNumber += 1
    if Element == NCubes_Total-1:
        File.write('\n')

File.write('*End Assembly\n')
File.write('**\n')

# Write materials
File.write('** MATERIALS\n')
File.write('**\n')
File.write('*Material, name=Elastic_UMAT\n')
File.write('*User Material, constants=2\n')
File.write(str(E) + ', ' + str(Nu) + '\n')

# Write dependent variables
File.write('*DEPVAR\n')
File.write('9\n')
File.write('1, F11,\n')
File.write('2, F12,\n')
File.write('3, F13,\n')
File.write('4, F21,\n')
File.write('5, F22,\n')
File.write('6, F23,\n')
File.write('7, F31,\n')
File.write('8, F32,\n')
File.write('9, F33\n')
File.write('** ----------------------------------------------------------------\n')
File.write('**\n')

# Write step
File.write('** STEP: Compression\n')
File.write('**\n')
File.write('*Step, name=Compression, nlgeom=YES\n')     # nlgeom=YES for F different from identity
File.write('Static compression\n')
File.write('*Static\n')
File.write('1., 1., 1e-05, 1.\n')
File.write('**\n')

## Write boundary conditions
File.write('** BOUNDARY CONDITIONS\n')
File.write('**\n')
File.write('** Name: Disp-BC-1 Type: Displacement/Rotation\n')
File.write('*Boundary\n')
Relative_Compression = CubeLength * Compression
File.write('TOPNODES, 3, 3, -' + str(Relative_Compression) + '\n')
File.write('** Name: Disp-BC-2 Type: Displacement/Rotation\n')
File.write('*Boundary\n')
File.write('BOTTOMNODES, 3, 3\n')
File.write('**\n')

## Write output requests
File.write('** OUTPUT REQUESTS\n')
File.write('**\n')
File.write('*Restart, write, frequency=0\n')
File.write('**\n')
File.write('** FIELD OUTPUT: F-Output-1\n')
File.write('**\n')
File.write('*Output, field\n')
File.write('*Element Output\n')
File.write('SDV1,\n')
File.write('SDV2,\n')
File.write('SDV3,\n')
File.write('SDV4,\n')
File.write('SDV5,\n')
File.write('SDV6,\n')
File.write('SDV7,\n')
File.write('SDV8,\n')
File.write('SDV9,\n')
File.write('*Node Output\n')
File.write('U,\n')
File.write('**El Print\n')
File.write('**DG,\n')
File.write('*Output, history, frequency=0\n')
File.write('*End Step\n')

File.close()

# Write grid in mhd
ImageArray = np.zeros((NCubes+1,NCubes+1,NCubes+1))
Spacing = np.array([NodesCoordinates[1]-NodesCoordinates[0],
                    NodesCoordinates[1]-NodesCoordinates[0],
                    NodesCoordinates[1]-NodesCoordinates[0]])
Offset = np.array([NodesCoordinates[0],
                   NodesCoordinates[0],
                   NodesCoordinates[0]])
WriteMHD(ImageArray, Spacing, Offset, FilePath, 'Grid', PixelType='float')